
Pickles CSS を使用したコーディング、運用、拡張についての基本ルールを示します。


【モジュールの種類】

Pickles CSS のモジュールは、次の3種類に分類されます。

・スタティックモジュール
・パーツモジュール
・ユニットモジュール

■[[guideline.static|スタティックモジュール]]

テーマやメディアタイプなどによらず、常に固定の効果をもたらす静的なモジュールです。主に視覚効果をそのままモジュール名に採用したようなモジュールで構成されており、直接的な効果を提供します。

但し、スタティックモジュールはその性質上、提供する効果には融通が利きません。多用すると、将来デザインの修正や、未知の新しいユーザエージェントに対応する要件が発生するなどの場合に、円滑な対応の妨げとなる可能性があります。なるべく使用せずに解決するように心がけてください。

■[[guideline.parts|パーツモジュール]]

基本的なパーツを部品化して定義したものです。複数の部品を組み合わせて使用することができます。

パーツモジュールは、見た目のスタイルより意味付けを重要視して設計されます。ユーザエージェントの種類によって、提供されるプレゼンテーションが異なるものがあります。

■[[guideline.unit|ユニットモジュール]]

ユニット単位で部品化されたモジュールです。モジュール名には、プレフィックス <code>unit_</code> が付加されます。

ユニットとは、水平貫通の矩形ブロックとしてレイアウトされる単位のことを指します。文書構造上のセクションとは直接関係しません。

ユニットモジュールが許可した範囲において、ユニットモジュール内にパーツモジュールを組み込んで使用することができます。

【プロジェクト独自拡張モジュールの追加】

テーマの管理者は、プロジェクト別に独自のモジュールを追加することができます。

ただし、追加されるモジュールは、将来のデザインの改修に備えて、他のテーマに切り替えても適用される必要があります。

このため、プロジェクト独自拡張モジュールのベースは、共有リソースディレクトリ内の下記のファイルに実装するようにします。

・<code>/common/css/modules.css</code>

このCSSファイルが存在する場合、テーマはこれをロードしなければなりません。

これにより、プロジェクト独自拡張モジュールは複数のテーマ間で共有することができます。


【コンテンツの領域の定義】

コンテンツは、要素 <code>#content</code> (通常これはdiv要素)で囲われた領域の中に展開されます。<code>#content</code>の内側がコンテンツ領域、それ以外がテーマの領域です。

コンテンツは基本的には、テーマが提供するモジュールを使用してコーディングを行うので、テーマの意図したスタイルはコンテンツ内に反映されます。

逆に、コンテンツが独自に実装するモジュール([[#cont_contmodule|後述]])は、<code>#content</code>の外側へ影響してはなりません。



■コンテンツ実装にかかる基本方針

テーマは、将来発生する新たな要求に対応するため、コンテンツが実装したコードに対して、適用スタイルの変更を実施したり、あるいは一括してなんらかの加工を加える可能性があります。そのため、コンテンツは『テーマの管理者が意図しない、あるいは把握できない独自のコードは持たない』ということが基本方針となります。

コンテンツは独自のモジュールを追加([[#cont_contmodule|後述]])することもできますが、むやみに多用すると、プロジェクト全体の統一性を欠き、メンテナンスが困難になる原因となり得るので、注意が必要です。



<html>
<h2 id="cont_contmodule">コンテンツ独自のモジュールの追加</h2>
</html>

テーマが提供するモジュール以外に、コンテンツ制作者は、次のルールに基づいて独自のモジュールを追加することができます。

・<code>#content</code> の中にだけ有効になるように作成してください。テーマ制作者は、コンテンツソースを <code>#content</code> の直下に配置することを保障します。それ以外の領域に、コンテンツ独自のスタイルシートを影響させてはいけません。
・コンテンツ制作者が定義したスタイルシートは、単一のコンテンツにのみ有効です。コンテンツ制作者は、複数のコンテンツで利用できるスタイルシートを定義できません。これは、テーマ制作者の仕事となります。
・コンテンツ制作者が独自に定義するスタイルシートでは、IDやクラス名にプレフィックス「<code>cont_</code>」を付加してください。(JavaScriptの関数名やPHPのクラス名などでも同様です)

また、特にモジュールの規則が許可している場合を除き、テーマによって提供されたモジュールの一部に対する拡張、あるいはそれに依存する拡張は認められません。これは、テーマによって元のスタイルが一様であるとは限らないためです。


【モジュールの設計に関するガイドライン】

HTMLの言語仕様上、文書構造を表現するHTMLと、スタイルを定義するCSSは別のソースコードとして分離されます。しかし、モジュールの概念を維持するには、この2つが合わせて管理されている必要があります。

次に示すモジュールの管理手順は、これを満たすために推奨される指針です。常に厳格に守らなければならない規則ということではありませんが、効率的なモジュール管理のために有効です。

・モジュールには、必ずユニークな名前を与え。モジュールのルートエレメントのクラス名は、モジュール名と同じにする。
・モジュール内で使用するクラス名は、モジュール名をプレフィックスに持つ名前を付ける。
・モジュール内で使用するクラスは、モジュール内に置かれた場合にのみ効果があるように実装する。
・モジュールに関連するクラスは、CSSファイル上で1まとめにして記述する。離れたところに関連する実装を記述しない。
・複数のモジュールを合成するような設計にしない。特別な理由があって合成する方が都合がいい場合には、使い方、管理方針についてガイドライン上に明示する。

■実装サンプル

次の例は、<code>.cont_sample</code> という拡張モジュールを実装する例です。

ただし、<code>.cont_sample</code> は、コンテンツ独自モジュールとして実装する場合の例なので、プレフィックス <code>cont_</code> を付加しています。テーマで定義する場合は、このプレフィックスは付加せず、<code>.sample</code> のような名前を付けてください。

□拡張モジュールの定義

CODE> @charset "UTF-8";
CODE> /* .cont_sample */
CODE> .cont_sample{
CODE> }
CODE> /* / .cont_sample */

CODE> <div class="cont_sample">
CODE> 	<p>サンプル。</p>
CODE> </div><!-- / .cont_sample -->

このモジュールは、モジュール名は <strong>cont_sample</strong> です。同じ名前で、モジュールのルートエレメントのクラス名を作成しています。

□拡張モジュールの実装

CODE> @charset "UTF-8";
CODE> /* .cont_sample */
CODE> .cont_sample{
CODE> }
CODE> .cont_sample .cont_sample_a{
CODE>     color:#ff0000;
CODE> }
CODE> .cont_sample .cont_sample_b{
CODE>     color:#0000ff;
CODE> }
CODE> /* / .cont_sample */

CODE> <div class="cont_sample">
CODE> 	<p>サンプル。</p>
CODE> 	<p class="cont_sample_a">サンプル内の sample_a。</p>
CODE> 	<p class="cont_sample_b">サンプル内の sample_b。</p>
CODE> </div><!-- / .cont_sample -->

モジュール内で定義するクラス名は、プレフィックスにモジュール名を付けるようにし、モジュール内でのみ有効になるように設計します。
ここでは、<code>.cont_sample .cont_sample_a</code> と <code>.cont_sample .cont_sample_b</code> というクラスを定義しました。

□拡張モジュールの複製

CODE> @charset "UTF-8";
CODE> /* .cont_sample */
CODE> .cont_sample{
CODE> }
CODE> .cont_sample .cont_sample_a{
CODE>     color:#ff0000;
CODE> }
CODE> .cont_sample .cont_sample_b{
CODE>     color:#0000ff;
CODE> }
CODE> /* / .cont_sample */
CODE> 
CODE> /* .cont_sample2 */
CODE> .cont_sample2{
CODE> }
CODE> .cont_sample2 .cont_sample2_a{
CODE>     color:#ff0000;
CODE> }
CODE> .cont_sample2 .cont_sample2_b{
CODE>     color:#0000ff;
CODE> }
CODE> /* / .cont_sample2 */

CODE> <div class="cont_sample">
CODE> 	<p>サンプル。</p>
CODE> 	<p class="cont_sample_a">サンプル内の sample_a。</p>
CODE> 	<p class="cont_sample_b">サンプル内の sample_b。</p>
CODE> </div><!-- / .cont_sample -->
CODE> 
CODE> <div class="cont_sample2">
CODE> 	<p>サンプル。</p>
CODE> 	<p class="cont_sample2_a">サンプル内の sample2_a。</p>
CODE> 	<p class="cont_sample2_b">サンプル内の sample2_b。</p>
CODE> </div><!-- / .cont_sample2 -->

似ているからといって、モジュール同士を安易に合成してはいけません。独立したモジュールとして別に再定義するのが基本です。

この例は、<code>.cont_sample</code> と似ている別のモジュール <code>.cont_sample2</code> を作成しました。

この処理で行ったことは、(1)CSS中の <code>.cont_sample</code> のブロックをまとめて複製し、(2)HTML中の <code>.cont_sample</code> のブロックもまとめて複製し、(3)それぞれ <code>.cont_sample</code> を <code>.cont_sample2</code> に置換しただけです。モジュール単位でまとめて実装されていれば、モジュールの複製や移植を簡単な手順で行うことができます。


